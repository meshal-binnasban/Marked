\documentclass[11pt]{article}

\title{Progress Report - 9 Months}
\author{Meshal Binnasban}
\date{\today}

\begin{document}

\maketitle

This report presents the progress achieved during the first nine months of my PhD research at King's College London. The research investigates the use of the marked approach for regular expression matching, aiming to develop an alternative to derivative-based algorithms while supporting full value extraction and POSIX disambiguation.

\section*{Project Synopsis}

This research investigates the use of the marked approach for regular expression matching, aiming to address limitations found in derivative-based methods, such as the exponential growth of derivatives that can slow down the matching process. The study focuses on developing and implementing the marked approach by writing key code and functions to control the movement of marks through regular expressions. Additionally, it explores bitcoded matching techniques, including the implementation of several functions to effectively track match paths and reconstruct parse trees. The research also examines disambiguation strategies to replicate POSIX behavior, tackling complex constructs like nested STAR operations and bounded repetitions (NTIMES). Comparative analyses with derivative-based matchers are conducted to identify counterexamples and refine the approach. The ultimate goal is to develop an efficient and reliable alternative to derivative-based matching algorithms that adheres to POSIX semantics.

\section{Outline}

\begin{enumerate}
    \item Derivatives: old technology rediscovered
    \item Exploding size problem
    \item Simplification attempts (still examples where they explode)
    \item Motivation: POSIX disambiguation and limitations of existing approaches
    \item Marked approach with multiple versions
\end{enumerate}

\section{Derivatives}

Derivatives of regular expressions were introduced by Brzozowski~\cite{Brzozowski1964} and later applied in functional settings~\cite{Owens2009, Might2009}. Given a regex $r$, the derivative $d_a(r)$ denotes a new regex that matches all suffixes of strings in $L(r)$ that start with the character $a$. 

\textbf{Example:}\\
Given $r = a \cdot b$, we have:
\[
d_a(a \cdot b) = d_a(a) \cdot b = \varepsilon \cdot b = b
\]

Although simple and elegant, derivative computation can lead to an exponential number of intermediate expressions.

\section{The Problem of Size Explosion}

One core issue with derivatives is the uncontrolled growth in the number and size of expressions during matching. For instance, even a simple regex like $(a + b)^* \cdot c$ leads to many distinct expressions when derivatives are taken repeatedly.

\textbf{Example:}\\
Let $r = (a + b)^* \cdot c$, and consider the string $aaac$. The repeated derivatives:
\[
d_a(d_a(d_a(d_a(r)))) 
\]
involve nested alternations and sequences, and simplification becomes costly.

\section{Simplification Attempts}

To manage size, we apply simplifications such as:
\begin{itemize}
    \item $r + \emptyset = r$
    \item $\emptyset + r = r$
    \item $r \cdot \varepsilon = r$
    \item $\varepsilon \cdot r = r$
    \item $r + r = r$
\end{itemize}

However, even with these simplifications, the size can grow prohibitively. Some expressions generate deeply nested trees that require aggressive normalization strategies to keep manageable.

\textbf{Example:}\\
Regex: $((a + \varepsilon)^* + b)^* \cdot c$, with input $a^n c$ leads to exponential unfolding.

\section{Motivation}

While derivatives allow matching, they do not provide full parse trees or control over disambiguation. In lexing contexts—especially POSIX-compliant tools—returning the correct parse matters. Our goal is to build a matching engine that:
\begin{itemize}
    \item Extracts full match values, not just accept/reject,
    \item Supports POSIX disambiguation,
    \item Tracks bitcoded paths for reconstructing parse trees.
\end{itemize}

\section{The Marked Approach: Versions and Implementation}

We follow the general idea introduced in~\cite{Fischer2010} and~\cite{Asperti2010}, where matching is guided by inserting marks (or points) into the regex. The mark is used to track how the input is matched, and later extract a bitcode or parse value.

\subsection*{Version 1: Value Extraction with Points}

In the first version, a single mark is inserted using a \emph{POINT} constructor, wrapping a character. The shift function propagates this mark through the regex.

\textbf{Shift behavior:}
\begin{enumerate}
    \item If the regex is a character and the mark is active and input matches: return a POINT.
    \item If the regex is ALT ($r_1 + r_2$), shift both sides.
    \item If the regex is SEQ ($r_1 \cdot r_2$), shift $r_1$ first. If $r_1$ is nullable, also shift into $r_2$.
    \item If the regex is STAR, recursively shift into the body.
\end{enumerate}

\textbf{mkfin}: Used to extract bitcode when part or all of the regex becomes final.

\textbf{mkeps}: Extracts how the empty string matches if the regex is nullable.

\textbf{Example:}\\
Regex: $(a + b) \cdot a$ with input $aa$\\
The POINT may follow one path, say Left then Right (bitcode $[0, 1]$), but some possible correct values are lost because some POINTs get overwritten during shifting.

\subsection*{Version 2: Propagating Bit Sequences in POINT}

We extend POINT to store a bitcode list that accumulates during shifting.

\textbf{Example:}\\
Regex: $(a + a) \cdot a$ with input $aa$\\
Two parses possible: Left-Right or Right-Right. We propagate bits like $[L, R]$ or $[R, R]$ into the POINT. However, only one POINT is preserved (others get replaced), meaning we lose some values.

\textbf{Key challenge:} Mark replacement discards alternative parses that may be POSIX-preferred.

\subsection*{Version 3: Tracking All Paths}

We change POINT to carry a list of bitcode lists. During shifting, all valid bitcode paths are preserved.

\textbf{mkfin} now returns a full list of all possible matching bitcodes.\\
\textbf{mkeps} extracts all nullability-based values.

\textbf{Example:}\\
Regex: $(a + b)^* \cdot c$, input: $aabc$\\
Bitcode paths like $[N, L, L, R, E]$ and $[N, L, R, E]$ are captured. This version passed validation against a derivative-based POSIX engine using over 10 billion tests.

We believe this version computes all possible parse paths that lead to acceptance. The POSIX value can then be selected using disambiguation.

\subsection*{Version 4: Input-Carrying Marks}

In this version, each mark holds its own input string. Initially, we have a single active mark with the full input. Shifting consumes the input and returns new marks.

\textbf{Example:}\\
Regex: $a^* \cdot b$, Input: $aaab$\\
Marks carry: $aaab \to aab \to ab \to b \to \varepsilon$

A regex is final if one mark has consumed all characters.

\textbf{Advantages:}
\begin{itemize}
    \item We can represent suspended marks for later resumption.
    \item It enables future features like controlling STAR behavior (e.g., delaying or preferring paths).
    \item Prioritization can be based on mark content, not just regex structure.
\end{itemize}

\section{Conclusion and Future Work}

This report presented four distinct versions of a marked regular expression matcher, each building toward full POSIX-correct value extraction. We validated version 3 against a reference engine and laid the foundation for value disambiguation in version 4.

Future plans:
\begin{itemize}
    \item Refine disambiguation logic in version 4.
    \item Implement NTIMES and STAR disambiguation under POSIX.
    \item Compare run-time performance against derivatives.
\end{itemize}

\bibliographystyle{abbrv}
\bibliography{urules}

\end{document}
